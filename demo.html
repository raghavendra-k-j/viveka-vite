<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Voice to LaTeX Renderer</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css"
    />
    <style>
      body {
        font-family: sans-serif;
        padding: 2rem;
        max-width: 800px;
        margin: auto;
      }
      .paragraph {
        margin-bottom: 1rem;
      }
      .latex {
        display: inline-block;
        margin: 0 4px;
      }
      #output {
        margin-top: 2rem;
      }
      #speechButton {
        padding: 10px 20px;
        font-size: 1rem;
        cursor: pointer;
      }
      #loader {
        display: none;
        text-align: center;
        margin-top: 1rem;
      }
      .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #555;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        display: inline-block;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      table {
        margin-top: 2rem;
        width: 100%;
        border-collapse: collapse;
      }
      table,
      th,
      td {
        border: 1px solid #ddd;
      }
      th,
      td {
        padding: 8px;
        text-align: left;
      }
      th {
        background-color: #f4f4f4;
      }
      tfoot {
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <h1>ðŸŽ¤ Voice to LaTeX Formatter</h1>
    <p>
      Speak a theorem or math explanation. It will render your exact input,
      distinguishing between text and LaTeX, and allow light corrections like
      casing.
    </p>
    <button id="speechButton">ðŸŽ¤ Start Listening</button>
    <div id="output"></div>
    <div id="loader">
      <div class="spinner"></div>
      <p>Formatting input, please wait...</p>
    </div>

    <h2>Token Usage</h2>
    <table id="tokenTable">
      <thead>
        <tr>
          <th>Request Number</th>
          <th>Prompt Token Count</th>
          <th>Candidate Token Count</th>
          <th>Total Token Count</th>
          <th>Cost (USD)</th>
          <th>Cost (INR)</th>
        </tr>
      </thead>
      <tbody>
        <!-- Token data rows will be inserted here -->
      </tbody>
      <tfoot>
        <tr>
          <td colspan="4">Total</td>
          <td id="totalUSD">$0.00</td>
          <td id="totalINR">â‚¹0.00</td>
        </tr>
      </tfoot>
    </table>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
    <script>
      const API_KEY = "AIzaSyBpaFLWAyzI3SgtL2E6zig14xZFuXvzxkc";
      const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${API_KEY}`;

      const speechButton = document.getElementById("speechButton");
      const outputDiv = document.getElementById("output");
      const loader = document.getElementById("loader");
      const tokenTable = document
        .getElementById("tokenTable")
        .getElementsByTagName("tbody")[0];
      const totalUSDCell = document.getElementById("totalUSD");
      const totalINRCell = document.getElementById("totalINR");

      const recognition = new (window.SpeechRecognition ||
        window.webkitSpeechRecognition)();
      recognition.lang = "en-US";
      recognition.continuous = true;
      recognition.interimResults = true;

      let finalTranscript = "";
      let isListening = false;
      let debounceTimeout = null;
      let previousContext = "";
      let requestCount = 0;

      const inputCostPerMillionTokens = 0.075; // USD per million tokens for input
      const outputCostPerMillionTokens = 0.3; // USD per million tokens for output
      const usdToInrConversionRate = 85; // Conversion rate from USD to INR

      speechButton.onclick = () => {
        if (!isListening) {
          recognition.start();
          isListening = true;
          speechButton.textContent = "ðŸ›‘ Stop Listening";
        } else {
          recognition.stop();
          isListening = false;
          speechButton.textContent = "ðŸŽ¤ Start Listening";
        }
      };

      recognition.onresult = (event) => {
        let interim = "";
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) {
            finalTranscript += transcript + " ";
          } else {
            interim += transcript;
          }
        }

        clearTimeout(debounceTimeout);
        debounceTimeout = setTimeout(() => {
          if (finalTranscript.trim()) {
            processSpeech(finalTranscript.trim());
            finalTranscript = "";
          }
        }, 2000);
      };

      recognition.onend = () => {
        if (isListening) recognition.start();
      };

      async function processSpeech(userInput) {
        const combinedInput = previousContext + "\n" + userInput;
        console.log("Sending to model:", combinedInput);
        showLoader(true);

        try {
          const { paragraphs, tokenUsage } = await fetchStructuredContent(
            combinedInput
          );
          renderParagraphs(paragraphs);
          renderTokenUsage(tokenUsage);
          previousContext += "\n" + userInput;
        } catch (error) {
          outputDiv.innerHTML = `<p style="color:red;">Error: ${error.message}</p>`;
        } finally {
          showLoader(false);
        }
      }

      async function fetchStructuredContent(userInput) {
        const payload = {
          contents: [
            {
              role: "user",
              parts: [{ text: userInput }],
            },
          ],
          systemInstruction: {
            role: "user",
            parts: [
              {
                text: `You are a LaTeX formatting assistant. The user is speaking math and scientific expressions over time.

Instructions:
- DO NOT solve, expand, differentiate, simplify, or evaluate anything.
- Just reformat the input cleanly and understandably.
- Allow light corrections like fixing "capital A" to "a", or "why" to "y", when clearly meant.
- If the user repeats something like "a is equal to 2" and "b is equal to 3", just clean and retain it.
- The user may speak in fragmentsâ€”accumulate those as context and treat each as a continuation.

Output must be a JSON array of paragraphs. Each paragraph is an array of text runs:
{
  "type": "text" | "latex",
  "content": string
}

Use "latex" only for math parts, and "text" for all else.
DO NOT include anything the user didn't explicitly say.`,
              },
            ],
          },
          generationConfig: {
            temperature: 0.7,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 2048,
            responseMimeType: "application/json",
            responseSchema: {
              type: "array",
              items: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    type: { type: "string" },
                    content: { type: "string" },
                  },
                  required: ["type", "content"],
                },
              },
            },
          },
        };

        const response = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });

        const data = await response.json();
        const text = data?.candidates?.[0]?.content?.parts?.[0]?.text?.trim();

        if (!text) throw new Error("No valid response from Gemini API");

        const tokenUsage = {
          promptTokenCount: data?.usageMetadata?.promptTokenCount,
          candidatesTokenCount: data?.usageMetadata?.candidatesTokenCount,
          totalTokenCount: data?.usageMetadata?.totalTokenCount,
        };

        let cleaned = text;
        if (cleaned.startsWith("```json")) {
          const match = cleaned.match(/```json\\s*([\\s\\S]+?)\\s*```/);
          if (match) cleaned = match[1];
        }

        return {
          paragraphs: JSON.parse(cleaned),
          tokenUsage,
        };
      }

      function renderParagraphs(paragraphs) {
        outputDiv.innerHTML = ""; // Clear old content
        const container = document.createElement("div");
        paragraphs.forEach((runs) => {
          const p = document.createElement("div");
          p.className = "paragraph";
          runs.forEach((run) => {
            const span = document.createElement("span");
            if (run.type === "text") {
              span.textContent = run.content;
            } else if (run.type === "latex") {
              span.className = "latex";
              try {
                katex.render(run.content, span, { throwOnError: false });
              } catch (e) {
                span.textContent = `[Invalid LaTeX: ${run.content}]`;
              }
            }
            p.appendChild(span);
          });
          container.appendChild(p);
        });
        outputDiv.appendChild(container);
      }

      function renderTokenUsage(tokenUsage) {
        requestCount++;
        const row = tokenTable.insertRow();
        row.insertCell(0).textContent = requestCount;
        row.insertCell(1).textContent = tokenUsage.promptTokenCount;
        row.insertCell(2).textContent = tokenUsage.candidatesTokenCount;
        row.insertCell(3).textContent = tokenUsage.totalTokenCount;

        // Calculate the cost
        const promptCost =
          (tokenUsage.promptTokenCount / 1_000_000) * inputCostPerMillionTokens;
        const outputCost =
          (tokenUsage.candidatesTokenCount / 1_000_000) *
          outputCostPerMillionTokens;
        const totalCostUSD = promptCost + outputCost;
        const totalCostINR = totalCostUSD * usdToInrConversionRate;

        row.insertCell(4).textContent = `$${totalCostUSD.toFixed(6)}`;
        row.insertCell(5).textContent = `â‚¹${totalCostINR.toFixed(2)}`;

        updateTotalCost(totalCostUSD, totalCostINR);
      }

      function updateTotalCost(costUSD, costINR) {
        const totalUSD =
          parseFloat(totalUSDCell.textContent.replace("$", "")) + costUSD;
        const totalINR =
          parseFloat(totalINRCell.textContent.replace("â‚¹", "")) + costINR;

        totalUSDCell.textContent = `$${totalUSD.toFixed(6)}`;
        totalINRCell.textContent = `â‚¹${totalINR.toFixed(2)}`;
      }

      function showLoader(show) {
        loader.style.display = show ? "block" : "none";
      }
    </script>
  </body>
</html>
